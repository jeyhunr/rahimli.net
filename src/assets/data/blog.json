{
  "blogs": [
    {
      "id": "1",
      "title": "API Gateway",
      "description": "an API gateway is a server that acts as an entry point for all requests coming from external clients or services. It serves as a single point of contact for clients to interact with the underlying microservices or APIs in your system.",
      "content": "An API gateway is a server that acts as an entry point for all requests coming from external clients or services. It serves as a single point of contact for clients to interact with the underlying microservices or APIs in your system. <br /> <br /> The main purpose of an API gateway is to provide a unified interface for your clients and handle cross-cutting concerns such as security, rate-limiting, load-balancing, caching, and request/response transformations. By doing so, it simplifies the client’s interaction with the backend services and makes the system more scalable, secure, and manageable. <br /> <br /> Example: Let’s say we have a simple e-commerce application that consists of multiple microservices, including an order service, a user service, and a product service. Each microservice has its own RESTful API that handles specific functionalities of the application. However, in order to access these microservices and interact with the application, the client would need to make requests to each individual API endpoint, which can be cumbersome and inefficient. This is where an API gateway comes in. <br /> <br /> The API gateway acts as a single entry point for the client to access all of the microservices, routing requests to the appropriate service based on the endpoint or operation being requested. It can also provide additional features such as request/response transformation, security, rate limiting, and caching. <br /> <br /> For example, suppose the client wants to view a product page on the e-commerce application. The client would make a request to the API gateway’s product endpoint, which would then forward the request to the product service. The product service would process the request and return the necessary information back to the API gateway, which would then return the data to the client. Similarly, if the client wants to create a new order, the client would make a request to the API gateway’s order endpoint, which would then forward the request to the order service. <br /> <br /> By using an API gateway, the client only needs to make requests to a single endpoint, which simplifies the overall architecture and improves performance. <br /> <br /> Here’s a basic example of an API gateway using Node.js and Express: <br /> <br /> <code>const express = require('express'); <br />const app = express(); <br /> // Define routes for each microservice <br /> app.use('/orders', require('./order-service')); <br />app.use('/users', require('./user-service')); <br />app.use('/products', require('./product-service')); <br /><br />// Start the API gateway server <br />app.listen(3000, () => { console.log('API Gateway server started on port 3000'); });</code>",
      "date": "2023-05-08",
      "tags": ["Cloud", "Microservices", "API Gateway"],
      "readTime": "5 min read"
    },
    {
      "id": "2",
      "title": "Configuring NestJS with DDEV",
      "description": "Step-by-step guide to setting up a NestJS application in DDEV.",
      "content": "NestJS is a powerful framework for building scalable server-side applications with TypeScript. In this blog post, we’ll guide you through the process of configuring a NestJS application in DDEV, step by step. <br /> <br /> **Step 1: Install DDEV** <br /> If you haven’t installed DDEV yet, head over to the official DDEV installation guide and follow the instructions for your operating system. <br /> <br /> **Step 2: Create an empty project** <br /> <code>$ mkdir ddev-nest-example</code><br /> **Step 3: Configure DDEV** <br /> <code>$ cd ddev-nest-example<br />$ ddev config</code><br /> After executing the above commands, a `.ddev` folder will be created. All we need is a `config.yaml` file in the `.ddev` directory. We have to modify the Node.js version in this file by simply adding `nodejs_version: \"20\"`. <br /> <br /> Now we can start our DDEV project using: <br /> <code>$ ddev start<br />$ ddev status<br />$ ddev ssh</code><br /> Actually, now we have an Nginx web server running locally (in a container), and we can access our local (container) Linux machine using `ddev ssh`. On our local machine, we can create a NestJS project, but first, we need to install the NestJS CLI on our local Linux machine. <br /> <br /> <code>$ npm install -g @nestjs/cli<br />$ nest new .<br />$ npm run start:dev</code><br /> After creating a new Nest project, we can start the project in development mode using `npm run start:dev`. <br /> <br /> **Nginx configuration:** <br /> <code><br />location / {<br />    absolute_redirect off;<br />    try_files $uri $uri/ /index.php?$query_string;<br />    proxy_pass http://localhost:3000; # Forward requests to your NodeJS app<br />    proxy_set_header Host $host;<br />    proxy_set_header X-Real-IP $remote_addr;<br />}<br />location ~ ^/ {<br />    proxy_pass http://localhost:3000; # Adjust the path as needed<br />    proxy_set_header Host $host;<br />    proxy_set_header X-Real-IP $remote_addr;<br />}</code><br /> <code>$ ddev restart<br />$ ddev ssh<br />$ npm run start:dev</code><br /> Now you can open your NestJS app in your browser using the DDEV URL, such as `your_project.ddev.site`.",
      "date": "2024-12-27",
      "tags": ["NestJS", "DDEV", "TypeScript"],
      "readTime": "10 min read"
    }
  ]
}
